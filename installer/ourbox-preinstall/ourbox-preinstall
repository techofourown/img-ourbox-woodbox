#!/usr/bin/env bash
# OurBox Woodbox — pre-installer
# Runs on TTY1 before Subiquity. Collects disk + identity from the operator,
# writes /autoinstall.yaml, then exits so Subiquity can run fully automated.
set -euo pipefail

# shellcheck disable=SC1091
source /cdrom/ourbox/tools/lib.sh

need_cmd lsblk
need_cmd readlink
need_cmd findmnt
need_cmd udevadm
need_cmd openssl
need_cmd envsubst
need_cmd awk
need_cmd sed

AUTOINSTALL_TPL="/cdrom/ourbox/autoinstall.tpl"
AUTOINSTALL_OUT="/autoinstall.yaml"

# ---------------------------------------------------------------------------
# helpers
# ---------------------------------------------------------------------------

banner() {
  clear
  echo
  echo "  =================================================================="
  echo "  OurBox Woodbox — Installer"
  echo "  =================================================================="
  echo
}

prompt_confirm_exact() {
  local expected="$1" prompt="$2" ans=""
  read -r -p "${prompt} " ans
  [[ "${ans}" == "${expected}" ]] || die "confirmation did not match (expected: ${expected})"
}

# ---------------------------------------------------------------------------
# disk detection
# ---------------------------------------------------------------------------

installer_disk() {
  # The disk backing the live USB (the one / is on)
  local src real parent
  src="$(findmnt -nr -o SOURCE / 2>/dev/null || true)"
  real="$(readlink -f "${src}" 2>/dev/null || echo "${src}")"
  parent="$(lsblk -no PKNAME "${real}" 2>/dev/null || true)"
  if [[ -n "${parent}" ]]; then
    echo "/dev/${parent}"
  else
    echo "${real}"
  fi
}

# OS disk candidates: NVMe, non-removable, not the installer USB.
candidate_disks() {
  local installer
  installer="$(installer_disk)"
  lsblk -dn -o NAME,TYPE | awk '$2=="disk" {print "/dev/"$1}' | while read -r disk; do
    [[ "${disk}" != "${installer}" ]] || continue
    local rm tran
    rm="$(lsblk -dn -o RM "${disk}" 2>/dev/null | tr -d '[:space:]')"
    [[ "${rm}" != "1" ]] || continue
    tran="$(lsblk -dn -o TRAN "${disk}" 2>/dev/null | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')"
    [[ "${tran}" == "nvme" ]] || continue
    echo "${disk}"
  done
}

# DATA disk candidates: non-removable, not the installer USB, not the OS disk.
# Any transport type (SATA, SAS, NVMe, etc.) — identified by exclusion, not size.
candidate_data_disks() {
  local installer os_disk
  installer="$(installer_disk)"
  os_disk="${TARGET_DISK}"
  lsblk -dn -o NAME,TYPE | awk '$2=="disk" {print "/dev/"$1}' | while read -r disk; do
    [[ "${disk}" != "${installer}" ]] || continue
    [[ "${disk}" != "${os_disk}" ]]  || continue
    local rm
    rm="$(lsblk -dn -o RM "${disk}" 2>/dev/null | tr -d '[:space:]')"
    [[ "${rm}" != "1" ]] || continue
    echo "${disk}"
  done
}

_disk_table_row() {
  local disk="$1" idx="$2"
  local size tran model serial
  size="$(lsblk -dn -o SIZE "${disk}" 2>/dev/null | tr -d '[:space:]')"
  tran="$(lsblk -dn -o TRAN "${disk}" 2>/dev/null | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')"
  model="$(lsblk -dn -o MODEL "${disk}" 2>/dev/null | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
  serial="$(lsblk -dn -o SERIAL "${disk}" 2>/dev/null | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
  [[ -n "${tran}" ]]   || tran="-"
  [[ -n "${model}" ]]  || model="-"
  [[ -n "${serial}" ]] || serial="-"
  printf '  %-3s %-14s %-8s %-6s %-22.22s %-16.16s\n' \
    "${idx}" "${disk}" "${size}" "${tran}" "${model}" "${serial}"
}

_disk_table_header() {
  printf '\n  %-3s %-14s %-8s %-6s %-22s %-16s\n' \
    "#" "Device" "Size" "Tran" "Model" "Serial"
  echo "  -----------------------------------------------------------------------"
}

print_disk_table() {
  local idx=0
  _disk_table_header
  while read -r disk; do
    idx=$((idx + 1))
    _disk_table_row "${disk}" "${idx}"
  done < <(candidate_disks)
  echo
}

print_data_disk_table() {
  local idx=0
  _disk_table_header
  while read -r disk; do
    idx=$((idx + 1))
    _disk_table_row "${disk}" "${idx}"
  done < <(candidate_data_disks)
  echo
}

select_disk() {
  local disks=() idx selected serial

  while true; do
    mapfile -t disks < <(candidate_disks)

    if (( ${#disks[@]} == 0 )); then
      echo
      echo "  No NVMe disks found (non-removable)."
      echo "  Make sure the NVMe drive is seated, then rescan."
      read -r -p "  Press ENTER to rescan, or q to quit: " _ans
      [[ "${_ans}" == "q" || "${_ans}" == "Q" ]] && die "operator quit"
      continue
    fi

    print_disk_table
    read -r -p "  Select OS disk number (r=rescan, q=quit): " _ans
    case "${_ans}" in
      r|R) continue ;;
      q|Q) die "operator quit" ;;
    esac

    [[ "${_ans}" =~ ^[0-9]+$ ]] || { log "invalid selection"; continue; }
    idx=$(( _ans - 1 ))
    (( idx >= 0 && idx < ${#disks[@]} )) || { log "selection out of range"; continue; }

    selected="${disks[${idx}]}"
    echo
    lsblk -o NAME,SIZE,MODEL,SERIAL,TYPE,FSTYPE,LABEL,MOUNTPOINTS "${selected}" || true
    echo
    prompt_confirm_exact "INSTALL-TO-THIS-DISK" \
      "  Type INSTALL-TO-THIS-DISK to confirm this is the OS disk:"

    serial="$(lsblk -dn -o SERIAL "${selected}" 2>/dev/null | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    TARGET_DISK="${selected}"
    TARGET_DISK_SERIAL="${serial}"
    return 0
  done
}

select_data_disk() {
  local disks=() idx selected

  while true; do
    mapfile -t disks < <(candidate_data_disks)

    if (( ${#disks[@]} == 0 )); then
      echo
      echo "  No DATA disk candidates found (non-removable, non-OS, non-USB)."
      echo "  Make sure the data drive is connected, then rescan."
      read -r -p "  Press ENTER to rescan, or q to quit: " _ans
      [[ "${_ans}" == "q" || "${_ans}" == "Q" ]] && die "operator quit"
      continue
    fi

    print_data_disk_table
    read -r -p "  Select DATA disk number (r=rescan, q=quit): " _ans
    case "${_ans}" in
      r|R) continue ;;
      q|Q) die "operator quit" ;;
    esac

    [[ "${_ans}" =~ ^[0-9]+$ ]] || { log "invalid selection"; continue; }
    idx=$(( _ans - 1 ))
    (( idx >= 0 && idx < ${#disks[@]} )) || { log "selection out of range"; continue; }

    selected="${disks[${idx}]}"
    echo
    lsblk -o NAME,SIZE,MODEL,SERIAL,TYPE,FSTYPE,LABEL,MOUNTPOINTS "${selected}" || true
    echo
    echo "  WARNING: ALL DATA ON ${selected} WILL BE PERMANENTLY ERASED"
    echo "  and formatted as the OurBox data volume (LABEL=OURBOX_DATA)."
    echo
    prompt_confirm_exact "FORMAT-AS-DATA" \
      "  Type FORMAT-AS-DATA to confirm this is the data disk:"

    DATA_DISK="${selected}"
    return 0
  done
}

# ---------------------------------------------------------------------------
# identity
# ---------------------------------------------------------------------------

prompt_nonempty() {
  local prompt="$1" default="${2:-}" ans=""
  if [[ -n "${default}" ]]; then
    read -r -p "  ${prompt} [${default}]: " ans
    ans="${ans:-${default}}"
  else
    read -r -p "  ${prompt}: " ans
  fi
  [[ -n "${ans}" ]] || die "value required"
  echo "${ans}"
}

prompt_password_hash() {
  local pw1="" pw2=""
  while true; do
    # echo after read -s moves the cursor to a new line; must go to stderr
    # so that only the hash is captured by $(...) on stdout.
    read -r -s -p "  Password: " pw1; echo >&2
    read -r -s -p "  Confirm:  " pw2; echo >&2
    [[ -n "${pw1}" ]] || { echo "  Password cannot be empty." >&2; continue; }
    [[ "${pw1}" == "${pw2}" ]] || { echo "  Passwords did not match. Try again." >&2; continue; }
    echo "${pw1}" | openssl passwd -6 -stdin
    return 0
  done
}

# ---------------------------------------------------------------------------
# main
# ---------------------------------------------------------------------------

main() {
  banner

  udevadm settle --timeout=10 || true

  # --- Step 1: OS disk ---
  echo "  Step 1 of 4: Select the OS disk"
  echo "  This disk will be ERASED and OurBox Woodbox OS installed on it."
  echo "  Showing NVMe disks only."

  TARGET_DISK=""
  TARGET_DISK_SERIAL=""
  select_disk

  echo
  echo "  OS disk     : ${TARGET_DISK}"
  echo "  Disk serial : ${TARGET_DISK_SERIAL:-unknown}"
  echo

  # --- Step 2: DATA disk ---
  banner
  echo "  Step 2 of 4: Select the DATA disk"
  echo "  This disk will be formatted as the OurBox data volume."
  echo "  Showing all non-OS, non-removable disks."

  DATA_DISK=""
  select_data_disk

  echo
  echo "  DATA disk   : ${DATA_DISK}"
  echo

  # --- Step 3: Identity ---
  banner
  echo "  Step 3 of 4: Set identity for the installed system"
  echo "  (You can change hostname and password later.)"
  echo

  OURBOX_HOSTNAME="$(prompt_nonempty "Hostname" "ourbox-woodbox")"
  OURBOX_USERNAME="$(prompt_nonempty "Username" "ourbox")"

  echo
  echo "  Set the login password for ${OURBOX_USERNAME}:"
  OURBOX_PASSWORD_HASH="$(prompt_password_hash)"

  # --- Step 4: Summary + final confirmation ---
  banner
  echo "  Step 4 of 4: Confirm and install"
  echo
  echo "  OS disk      : ${TARGET_DISK}"
  [[ -n "${TARGET_DISK_SERIAL}" ]] && \
    echo "  Disk serial  : ${TARGET_DISK_SERIAL}"
  echo "  DATA disk    : ${DATA_DISK}"
  echo "  Hostname     : ${OURBOX_HOSTNAME}"
  echo "  Username     : ${OURBOX_USERNAME}"
  echo
  echo "  WARNING: ALL DATA ON ${TARGET_DISK} AND ${DATA_DISK} WILL BE PERMANENTLY ERASED."
  echo
  prompt_confirm_exact "INSTALL" "  Type INSTALL to begin (or Ctrl-C to abort):"

  # --- generate autoinstall.yaml ---
  export OURBOX_HOSTNAME OURBOX_USERNAME OURBOX_PASSWORD_HASH OURBOX_DATA_DISK="${DATA_DISK}"

  # Match by device path (/dev/nvme0n1) rather than serial number.
  # Subiquity's prober reads the serial directly from sysfs, which includes
  # trailing spaces (e.g. "794PCBKPPQKN        ").  lsblk strips those spaces,
  # so a serial-based match always fails.  Path matching is unambiguous and
  # requires no serial normalization.
  TARGET_DISK_REAL="$(readlink -f "${TARGET_DISK}")"
  OURBOX_STORAGE_MATCH="        path: ${TARGET_DISK_REAL}"
  export OURBOX_STORAGE_MATCH

  [[ -f "${AUTOINSTALL_TPL}" ]] || die "missing runtime template: ${AUTOINSTALL_TPL}"

  RUNTIME_VARS='${OURBOX_HOSTNAME} ${OURBOX_USERNAME} ${OURBOX_PASSWORD_HASH} ${OURBOX_STORAGE_MATCH} ${OURBOX_DATA_DISK}'
  envsubst "${RUNTIME_VARS}" < "${AUTOINSTALL_TPL}" > "${AUTOINSTALL_OUT}"

  echo
  echo "  =================================================================="
  echo "  OurBox Woodbox is now installing."
  echo "  Do NOT remove the USB stick until the machine powers off."
  echo "  Installation takes approximately 10-15 minutes."
  echo "  =================================================================="
  echo
}

main "$@"
